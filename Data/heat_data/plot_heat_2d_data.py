#!/usr/bin/env python
"""plot_heat_2d_data.py
----------------------------------
Visualization script for the PCB heat dataset generated by generate_heat_2d_data.py
"""
from __future__ import annotations

import numpy as np
import matplotlib.pyplot as plt
from datasets import load_from_disk
from pathlib import Path
import matplotlib.colors as colors
from scipy.interpolate import griddata

def load_heat_dataset(dataset_path: str = "Data/heat_data/pcb_heat_adaptive_dataset9.0_n8192_N25_P10"):
    """Load the heat dataset from disk and extract parameters."""
    try:
        dataset = load_from_disk(dataset_path)
        
        # Check if this is adaptive mesh or uniform grid
        first_sample = dataset['train'][0]
        is_adaptive = 'grid_coords' in first_sample
        
        if is_adaptive:
            # Adaptive mesh dataset
            grid_coords = np.array(first_sample['grid_coords'])
            field_values = np.array(first_sample['field_values'])
            print(f"Dataset type: Adaptive mesh")
            print(f"  - Sample grid points: {len(grid_coords)}")
            grid_n = 64  # Default visualization grid size for adaptive mesh
        else:
            # Uniform grid dataset
            field_shape = np.array(first_sample['field']).shape
            grid_n = field_shape[0]  # field shape is (grid_n, grid_n, 1)
            print(f"Dataset type: Uniform grid")
            print(f"  - Grid size: {grid_n}×{grid_n}")
        
        # Analyze dataset to extract generation parameters
        train_data = dataset['train']
        source_counts = []
        all_powers = []
        
        # Sample a few examples to get parameter ranges
        sample_size = min(100, len(train_data))
        for i in range(sample_size):
            sources = np.array(train_data[i]['sources'])
            source_counts.append(len(sources))
            if len(sources) > 0:
                all_powers.extend(sources[:, 2].tolist())
        
        n_min = min(source_counts) if source_counts else 0
        n_max = max(source_counts) if source_counts else 0
        power_min = min(all_powers) if all_powers else 0
        power_max = max(all_powers) if all_powers else 0
        
        print(f"Dataset parameters detected:")
        print(f"  - Source count range: {n_min} to {n_max}")
        print(f"  - Power range: {power_min:.4f} to {power_max:.4f}")
        print(f"  - Train samples: {len(dataset['train'])}")
        print(f"  - Test samples: {len(dataset['test'])}")
        
        return dataset, grid_n, is_adaptive
    except Exception as e:
        print(f"Error loading dataset from {dataset_path}: {e}")
        return None, None, None

def plot_single_sample(sample, sample_idx=0, grid_n=64, save_path=None):
    """Plot a single heat sample with temperature field and source locations."""
    
    # Extract data
    sources = np.array(sample["sources"])  # shape: (n_sources, 3) -> [x, y, power]
    
    # Check if this is adaptive mesh or uniform grid
    is_adaptive = 'grid_coords' in sample
    
    # Create visualization grid (always uniform for plotting)
    x = np.linspace(0, 1, grid_n)
    y = np.linspace(0, 1, grid_n)
    X, Y = np.meshgrid(x, y, indexing='xy')
    
    if is_adaptive:
        # Adaptive mesh data - interpolate to regular grid for visualization
        grid_coords = np.array(sample["grid_coords"])  # (n_points, 2) -> [x, y]
        field_values = np.array(sample["field_values"])  # (n_points,)
        
        # Interpolate to regular grid for visualization
        field = griddata(grid_coords, field_values, (X, Y), method='cubic', fill_value=np.nan)
        field = np.nan_to_num(field, nan=0.0)  # Replace NaN with 0
        
        # Store adaptive points for visualization
        adaptive_coords = grid_coords
    else:
        # Uniform grid data
        field = np.array(sample["field"]).squeeze()  # remove channel dimension (raw temperature field)
        # Update grid to match data resolution
        actual_grid_n = field.shape[0]
        if actual_grid_n != grid_n:
            x = np.linspace(0, 1, actual_grid_n)
            y = np.linspace(0, 1, actual_grid_n)
            X, Y = np.meshgrid(x, y, indexing='xy')
        adaptive_coords = None
    
    # Single subplot layout: [ax_main | cbar_temp | cbar_power]
    fig = plt.figure(figsize=(10, 6))
    gs = fig.add_gridspec(
        1,
        3,
        width_ratios=[1, 0.04, 0.04],
        left=0.1,
        right=0.9,
        wspace=0.05,  # bring temp colorbar closer
    )
    ax_main = fig.add_subplot(gs[0, 0])
    cax_temp = fig.add_subplot(gs[0, 1])
    cax_power = fig.add_subplot(gs[0, 2])
    
    # Plot temperature field
    im = ax_main.contourf(X, Y, field, levels=20, cmap="hot")
    ax_main.contour(X, Y, field, levels=10, colors="black", alpha=0.3, linewidths=0.5)
    
    # Add heat sources
    if len(sources) > 0:
        scatter = ax_main.scatter(
            sources[:, 0],
            sources[:, 1],
            c=sources[:, 2],
            s=100,
            cmap="viridis",
            edgecolors="white",
            linewidth=2,
            label="Heat Sources",
        )
    
    # Adaptive points visualization removed per user request
    
    # Temperature colorbar (initial position from GridSpec)
    fig.colorbar(im, cax=cax_temp, label="Temperature")
    # Manually shift the temperature colorbar slightly left to hug the main plot
    temp_pos = cax_temp.get_position()
    shift = 0.085  # fraction of figure width to shift left
    cax_temp.set_position([temp_pos.x0 - shift, temp_pos.y0, temp_pos.width, temp_pos.height])
    
    # Add source power colorbar (right)
    if len(sources) > 0:
        fig.colorbar(scatter, cax=cax_power, label="Source Power")
    else:
        # If no sources, hide the power colorbar axis
        cax_power.set_visible(False)
    
    ax_main.set_xlabel("X position")
    ax_main.set_ylabel("Y position")
    ax_main.grid(True, alpha=0.3)
    ax_main.set_aspect("equal", adjustable="box")
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches="tight")
        print(f"Saved plot to {save_path}")
    
    return fig



def main():
    # Hardcoded settings
    dataset_path = "Data/heat_data/pcb_heat_adaptive_dataset9.0_n8192_N25_P10"
    output_dir = Path("Data/heat_data/plots")
    
    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Load dataset and auto-detect parameters
    print(f"Loading dataset from {dataset_path}...")
    dataset, grid_n, is_adaptive = load_heat_dataset(dataset_path)
    
    if dataset is None or grid_n is None:
        print("Failed to load dataset. Exiting.")
        return
    
    print(f"Dataset loaded: {len(dataset['train'])} train, {len(dataset['test'])} test samples")
    
    # Plot 3 samples from train set
    print("Plotting 3 samples from training set...")
    for i in range(3):
        sample = dataset['train'][i]
        save_path = output_dir / f"train_sample_{i+1}.png"
        plot_single_sample(sample, i, grid_n, save_path)
        plt.close()  # Close figure to save memory
    
    # Plot 3 samples from test set
    print("Plotting 3 samples from test set...")
    for i in range(3):
        sample = dataset['test'][i]
        save_path = output_dir / f"test_sample_{i+1}.png"
        plot_single_sample(sample, i, grid_n, save_path)
        plt.close()  # Close figure to save memory
    
    print("✅ Generated 6 plots total:")
    print("   - 3 training samples: train_sample_1.png, train_sample_2.png, train_sample_3.png")
    print("   - 3 test samples: test_sample_1.png, test_sample_2.png, test_sample_3.png")
    print(f"   - All saved in: {output_dir}")
    print(f"   - Plots generated for {grid_n}×{grid_n} grid resolution")

if __name__ == "__main__":
    main()
